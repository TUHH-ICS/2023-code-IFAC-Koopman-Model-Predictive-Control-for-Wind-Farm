function [CT_prime,phi,mpc] = SMPCcontroller_test(sol,Wp,mpc)

% initialize controller
mpc = MPCinit_ctrl(sol,Wp,mpc);

% solve mpc
if sol.k>=1
    
    xinit         = zeros(mpc.nx*Wp.turbine.N,1);
    xinit(mpc.Mf) = sol.turbine.force;% the axial force that a turbine exerts on the flow Fi(t)
    xinit(mpc.Mp) = sol.turbine.power;% the power generated by a turbine Pi(t)
    xinit(mpc.Mu) = sol.turbine.CT_prime;% a mean rotor-averaged wind velocity ¯vi(t) for i = 1, 2, . . . , N with N the number of turbines.
    
    yalmip('clear');
    
    cons = [];
    cost = 0;
    
    % define decision variables for the windfarm
    U    = sdpvar(Wp.turbine.N*mpc.Nh,1);
    
    % Ns is number of samples taken into account with the SMPC
    Ns      = 6;
    % mean_v is the measured wind speed
    mean_v  = sol.turbine.Ur;
    % sigma_v is the standard deviation of stochastic wind speed
    sigma_v = .5;
    
    for ll=1:Ns
        
        
        noise     = sigma_v*randn(Wp.turbine.N,mpc.Nh);
        mpc.V     = repmat(mean_v,1,mpc.Nh) + noise;
        
        % build wind farm model
        mpc       = wfmodel(sol,Wp,mpc,ll,2);
        
        % build matrices horizon
        mpc       = matrixsys(Wp,mpc,mpc.Nh,sol,xinit);
        
        X         = mpc.AA*xinit + mpc.BBt*U ;
        Y         = mpc.CC*X;
        P         = reshape(Y(mpc.MP),Wp.turbine.N,mpc.Nh) ;
        
        E(:,ll)   = mpc.Pref(sol.k:sol.k+mpc.Nh-1)-sum(P)';
        
        cost = cost + E(:,ll)'*mpc.Q/Ns*E(:,ll);
        
    end
    
    cons = [cons, mpc.um <= U <= mpc.uM];
    
    dU   = [ U(1:Wp.turbine.N)-sol.turbine.CT_prime ; U(Wp.turbine.N+1:end)-U(1:end-Wp.turbine.N)];
    
    cost = cost + dU'*mpc.R*dU;
    
    ops  = sdpsettings('solver','','verbose',0,'cachesolvers',1);%sdpsettings('solver','cplex','verbose',0,'cachesolvers',1)1
    
    optimize(cons,cost,ops)
    
    mpc = lemke_sol(mpc,Wp,xinit);
        
        
        %% verfication of the cost function.
       uTempTest = value(U);
       uTemp0 = uTempTest;
       figure; subplot(2,1,1);for idxPl = 1:5, plot(uTempTest(idxPl:9:end)), hold on;end
       subplot(2,1,2);for idxPl = 6:9, plot(uTempTest(idxPl:9:end)), hold on;end
        
        E0 = (mpc.L_tilde*xinit + mpc.S_tilde*uTempTest - mpc.Pref(sol.k:sol.k+mpc.Nh-1));
        mpc.U0 = [sol.turbine.CT_prime; uTempTest(1:(mpc.Nh-1)*Wp.turbine.N)];
        delta_U = (uTempTest - mpc.U0);
        mpc.J_U0 = (E0'*mpc.Q/Ns*E0)+   delta_U' * mpc.R * delta_U ; % cost function
        fprintf(' Orig value J: %2.3e\n', mpc.J_U0);
        J_temp = mpc.J_U0 + mpc.g*(uTempTest - uTemp0)+ (uTempTest - uTemp0)'* mpc.H*(uTempTest - uTemp0); %cost function aproximatiom
        fprintf(' Aprox. value J: %2.3e\n', J_temp);
        
        % Test small variation of u_opt
        %uTempTest = uTempTest + 0.001 *uTempTest;
        uTempTest = mpc.utemp;
        E0 = (mpc.L_tilde*xinit + mpc.S_tilde*uTempTest - mpc.Pref(sol.k:sol.k+mpc.Nh-1));
        mpc.U0 = [sol.turbine.CT_prime; uTempTest(1:(mpc.Nh-1)*Wp.turbine.N)];
        delta_U = (uTempTest - mpc.U0);
        mpc.J_U0test = E0'*mpc.Q*E0 +   delta_U' * mpc.R * delta_U ;
        fprintf(' Small change Orig value J: %2.3e\n', mpc.J_U0test);
        J_temp1 = mpc.J_U0test + mpc.g*(uTempTest - uTemp0)+ (uTempTest - uTemp0)'* mpc.H*(uTempTest - uTemp0); %cost function aproximatiom
        fprintf(' Aprox. value J: %2.3e\n', J_temp1);
        
        
        fprintf(' Orig value J: %2.3e\n', mpc.J_U0);
    
end

%% Assign the decision variables
Yopt          = value(Y);
Uopt          = Yopt(mpc.MU);
temp          = reshape(Uopt,[Wp.turbine.N,mpc.Nh]);

CT_prime      = temp(:,1);              % first action horizon
phi           = zeros(Wp.turbine.N,1);

end
